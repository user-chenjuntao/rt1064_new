# assigned_box_planner_greedy_1 算法文档

## 算法概述（简化版 v3）
- **核心策略**：贪心规划 + 障碍/箱子绕行，去掉拐点最小化和路径简化
- **选择箱子顺序**：按贪心策略（车到箱子+箱子到目标的曼哈顿距离最小）
- **车到推箱位**：先贪心移动，遇障碍或路径重复时贴障碍绕行，通畅后恢复贪心
- **推箱子**：贪心选择方向，检查死点；遇死点时贴箱子绕行到另一个推箱位
- **容量限制**：最多 10 个箱子，网格最大 400 单元格（20×20），路径缓存根据需要设置
- **目标匹配**：
  - 自动分配箱子到目标（贪心策略，每个箱子可对应任意目标点）
  - 支持目标数≥箱子数（多余目标不使用）
  - 箱子到达目标后，箱子消失（坐标标记为-1），目标点也不再被其他箱子使用

## 函数接口（v3 简化版）
```c
#include "assigned_box_planner_greedy_1.h"

int plan_boxes_greedy_v3(int rows, int cols, PlannerPointV3 car,
                         const PlannerPointV3 *boxes, size_t box_count,
                         const PlannerPointV3 *targets, size_t target_count,
                         const PlannerPointV3 *obstacles, size_t obstacle_count,
                         PlannerPointV3 *path_buffer, size_t path_capacity,
                         size_t *out_steps,
                         size_t *out_box_target_indices /* 可为 NULL */);
```

### 参数说明
- `rows/cols`：网格行数/列数，总单元格数需 ≤400
- `car`：小车初始坐标
- `boxes`/`box_count`：箱子列表及数量（最多 10 个，负坐标或越界的箱子会被忽略）
- `targets`/`target_count`：目标点列表及数量（需 ≥ 有效箱子数，多余目标不使用）
- `obstacles`/`obstacle_count`：障碍物列表及数量
- `path_buffer`/`path_capacity`：输出路径缓存及容量（仅包含小车轨迹，不含箱子位置）
- `out_steps`：输出实际路径步数
- `out_box_target_indices`：可选，输出箱子到目标的映射关系（下标对应 `targets` 数组，未分配为 `SIZE_MAX`）

### 返回值
- `0`：成功
- `-1`：参数为空或无效
- `-2`：箱子或目标为空
- `-3`：箱子数超限（>10）
- `-4`：路径缓存容量为0
- `-5`：单箱迭代超步数（5000步）
- `-6`：无可行推动方向或车无法到达推箱位
- `-7`：路径缓存容量不足
- `-8`：目标数少于箱子数

## 使用示例

### 基础示例（默认地图）
```c
#include "assigned_box_planner_greedy_1.h"

// 使用 rt1064/project/user/src/main.c 中的默认地图
// 14×10 网格
PlannerPointV3 car = {1, 2};
PlannerPointV3 boxes[] = {
    {1, 7},
    {7, 4},
    {10, 4},
};
PlannerPointV3 targets[] = {
    {9, 5},
    {9, 6},
    {9, 7},
};
PlannerPointV3 obstacles[] = {
    {5, 1},  {6, 1},  {7, 1},  {8, 1},
    {0, 7},  {2, 7},  {3, 7},  {4, 7},
    {4, 6},  {4, 5},  {5, 5},  {6, 5},
    {7, 5},  {8, 5},  {8, 6},  {8, 7},
    {8, 8},  {9, 8},  {10, 8}, {11, 8},
    {12, 8}, {12, 7}, {12, 6}, {12, 5},
    {12, 4}, {12, 3}, {11, 3}, {10, 3},
    {10, 5}, {10, 6}, {1, 9},
};

PlannerPointV3 path[2048];
size_t steps = 0;
size_t mapping[3] = {SIZE_MAX, SIZE_MAX, SIZE_MAX};  // 可为 NULL

int ret = plan_boxes_greedy_v3(14, 10, car,
                               boxes, 3,
                               targets, 3,
                               obstacles, sizeof(obstacles) / sizeof(obstacles[0]),
                               path, sizeof(path) / sizeof(path[0]),
                               &steps, mapping);

if (ret == 0) {
    // 成功规划
    printf("路径总步数: %zu\n", steps);
    
    // 打印箱子到目标的映射
    for (size_t i = 0; i < 3; ++i) {
        if (mapping[i] != SIZE_MAX) {
            printf("箱子[%zu] (%d,%d) -> 目标[%zu] (%d,%d)\n",
                   i, boxes[i].row, boxes[i].col,
                   mapping[i], targets[mapping[i]].row, targets[mapping[i]].col);
        }
    }
    
    // 遍历小车路径
    for (size_t i = 0; i < steps; ++i) {
        printf("步骤 %zu: (%d, %d)\n", i, path[i].row, path[i].col);
    }
} else {
    // 错误处理
    printf("规划失败，错误码: %d\n", ret);
    switch (ret) {
        case -1: printf("参数为空或无效\n"); break;
        case -2: printf("箱子或目标为空\n"); break;
        case -3: printf("箱子数超限\n"); break;
        case -4: printf("路径缓存容量为0\n"); break;
        case -5: printf("单箱迭代超步数\n"); break;
        case -6: printf("无可行推动方向\n"); break;
        case -7: printf("路径缓存容量不足\n"); break;
        case -8: printf("目标数少于箱子数\n"); break;
    }
}
```

### 算法特点说明

1. **贪心策略与目标分配**：
   - **初始分配**：使用贪心算法为每个箱子分配一个目标点（车到箱子+箱子到目标距离最小）
   - **箱子顺序**：按车到箱子+箱子到目标的总距离动态排序
   - **推箱方向**：评估所有4个方向，选择评分最优的
   - **评分公式**：`score = 箱子到目标距离×10 + 邻域拥挤度×5 + 反向惩罚 + 车到推箱位距离×2`
     * 优先考虑箱子接近目标（权重10，最高）
     * 其次避免拥挤位置（权重5，中等）
     * 再次考虑车的移动成本（权重2，较低）
     * 最后避免反向推动（5^n次方，n为连续反向次数，递进式惩罚）
       - 第1次反向：5
       - 第2次反向：25
       - 第3次反向：125
       - 第4次反向：625
       - 以此类推（指数级增长，强力防止震荡）
       - 改变方向后重置计数器
   - **多方向尝试**：如果最优方向的推箱位无法到达，自动尝试次优方向
     * 按评分排序所有可行方向
     * 从最优到次优依次尝试，直到成功
     * 避免因单一方向被阻挡而整体失败
   - **车已在推箱位**：正确处理车当前就在某个推箱位的情况（无需移动，直接推）
   - **箱子消失**：箱子到达目标后标记为(-1,-1)，后续路径规划中自动忽略
   - **目标独占**：每个目标点只分配给一个箱子，箱子到达后该目标不再被使用

2. **绕行机制（BFS限定区域搜索）**：
   - **触发条件**：检测路径重复（20步窗口内重复≥3次）或贪心移动遇障碍
   - **BFS绕行算法**：使用广度优先搜索在限定区域内寻找最短路径
     * **区域确定**：
       - 基础距离 = `行距离+1` 和 `列距离+1`
       - 如果某个距离为0，则使用另一个距离（保证横纵都有空间）
       - 以起点为中心，向四周扩展基础距离形成矩形区域
     * **边界限制**：
       - 检查起点到地图四边的距离
       - 如果基础距离超出边界，则以实际边界距离为准
       - 确保搜索区域不越界
     * **分区优化**：
       - 以起点行坐标为分界线，分为上下两区
       - 终点所在半区保持完整范围
       - 另一半区只保留2格行距离（避免向反方向过度搜索）
     * **BFS搜索**：
       - 在限定区域内使用BFS找最短路径
       - 自动避开障碍物和所有箱子
       - 保证找到的是区域内的最优路径
   
   - **绕行模式（车辆模式 vs 箱子模式）**：
     * **车辆模式** (`allow_greedy_resume = 1`)：
       - 用于车辆自由移动（不推箱子）
       - BFS搜索中每访问一个点都检测是否可恢复贪心
       - 一旦前方通畅，立即停止绕行切换回贪心
       - 效率高，路径可能更短
     * **箱子模式** (`allow_greedy_resume = 0`)：
       - 用于车辆绕行到精确推箱位
       - BFS搜索禁止中途打断
       - 必须完整到达目标推箱位才返回
       - 确保推箱位置精确，可靠性高
   
   - **绕行换推箱位（智能双模式策略）**：
     * 核心理解：绕箱换推箱位 = 绕障碍换推箱位 = 同一概念
     * 先用死点检测过滤出箱子周围4个推箱位中的有效推箱位（不会导致死锁）
     * 按评分排序有效推箱位（距离优先，兼顾拥挤度和车距）
     * 依次尝试每个推箱位：
       1. **车已在推箱位** → 直接成功
       2. **贪心到达** → 成功
       3. **车辆模式绕行**（第一次尝试）：
          - 使用BFS在限定区域搜索
          - 允许中途恢复贪心，提高效率
          - 验证是否到达推箱位
       4. **箱子模式绕行**（第二次尝试）：
          - 如果车辆模式未到达推箱位，从起点重新尝试
          - 禁止中途恢复贪心，确保到达推箱位
          - 必须完整到达目标推箱位（不会提前停止）
       5. **换方向的箱子模式**（第三次尝试）：
          - 尝试另一个绕行方向（左手/右手）
     * 多重保障：先追求效率（车辆模式），再追求可靠性（箱子模式）
     * 如果所有尝试都失败，自动尝试下一个推箱位

3. **死点检测与目标到达**：
   - **严格检测策略**：每次推箱前检查新位置能否继续到达目标
   - 使用BFS验证箱子从新位置的可达性（不放宽，确保不推入死角）
   - **目标点特殊处理**：
     * 当推箱后箱子直接到达目标点时，跳过死点检测（已经是终点）
     * 非目标点一律进行严格的BFS可达性验证
     * 如果所有通过检测的方向都无法到达推箱位，触发绕箱换推箱位

4. **路径输出**：
   - `path_buffer` 仅包含**小车轨迹**（不含箱子位置）
   - **保证连续性**：每一步都是相邻单元格（曼哈顿距离为1），只改变行或列之一
   - 内置多重路径验证机制：
     * 绕行路径复制时验证连续性
     * 贪心移动时验证每个新点与前一点相邻
     * 推箱后车位置验证连续性
     * 最终路径整体验证
   - 任何不连续都会被检测并返回错误码 -6
   - 建议缓存容量至少为 `rows × cols × box_count × 10`

### 推箱方向评分详解

#### 评分公式
```c
score = dist_after × 10 + adj_pen × 5 + reverse_pen + car_to_push × 2
```

#### 代价组成

| 代价项 | 权重 | 计算方式 | 目的 | 优先级 |
|--------|------|----------|------|--------|
| `dist_after` | ×10 | 曼哈顿距离(推后位置, 目标) | 确保箱子朝目标移动 | 🔴 最高 |
| `adj_pen` | ×5 | 统计推后位置周围4方向的障碍物/箱子数 | 避免推到狭窄位置 | 🟡 中等 |
| `reverse_pen` | 5^n | n=连续反向次数，5的n次方 | 防止来回推动震荡 | 🟠 递增 |
| `car_to_push` | ×2 | 曼哈顿距离(车, 推箱位) | 优化车的移动效率 | 🟢 较低 |

#### 反向惩罚递进表

| 连续反向次数 | 惩罚值 | 计算 | 说明 |
|-------------|--------|------|------|
| 0次（正常） | 0 | - | 不是反向移动 |
| 第1次反向 | 5 | 5^1 | 轻度惩罚 |
| 第2次反向 | 25 | 5^2 | 中度惩罚 |
| 第3次反向 | 125 | 5^3 | 重度惩罚 |
| 第4次反向 | 625 | 5^4 | 极重惩罚 |
| 第5次反向 | 3125 | 5^5 | 禁止性惩罚 |

**注意**：一旦改变方向（非反向），计数器自动归零。

#### 评分示例

假设有4个可行的推箱方向，当前状态：
- 箱子位置：(5, 5)
- 目标位置：(9, 7)
- 车位置：(4, 5)
- 上一次推动方向：向上 (dr=-1, dc=0)
- 连续反向次数：reverse_count = 0

**方向1：向上推**
```
推后位置：(4, 5)
dist_after = |4-9| + |5-7| = 7
adj_pen = 2 (周围有2个障碍物)
reverse_pen = 0 (不是反向，上次也是向上)
car_to_push = |4-6| + |5-5| = 2 (推箱位在(6,5))

score = 7×10 + 2×5 + 0 + 2×2 = 70 + 10 + 0 + 4 = 84
```

**方向2：向右推**
```
推后位置：(5, 6)
dist_after = |5-9| + |6-7| = 5
adj_pen = 3 (周围有3个障碍物)
reverse_pen = 0 (不是反向)
car_to_push = |4-5| + |5-4| = 2 (推箱位在(5,4))

score = 5×10 + 3×5 + 0 + 2×2 = 50 + 15 + 0 + 4 = 69
```

**方向3：向下推**（与上次推动相反！）
```
推后位置：(6, 5)
dist_after = |6-9| + |5-7| = 5
adj_pen = 1 (周围有1个障碍物)
reverse_pen = 5 (第1次反向，5^1=5)
car_to_push = |4-4| + |5-5| = 0 (推箱位在(4,5))

score = 5×10 + 1×5 + 5 + 0×2 = 50 + 5 + 5 + 0 = 60 ✅ 虽然是反向，但整体最优
```

**方向4：向左推**
```
推后位置：(5, 4)
dist_after = |5-9| + |4-7| = 7
adj_pen = 1 (周围有1个障碍物)
reverse_pen = 0 (不是反向)
car_to_push = |4-5| + |5-6| = 2 (推箱位在(5,6))

score = 7×10 + 1×5 + 0 + 2×2 = 70 + 5 + 0 + 4 = 79
```

**最终选择**：方向3（向下推），score=60最小
- 虽然是反向移动，但因为距离优势（dist_after=5）和低拥挤度（adj_pen=1），仍然是最优选择
- 如果下次再反向推回上，惩罚将变为25，大幅降低其评分

### BFS绕行区域示例

以 **起点(9,4) → 终点(11,4)** 为例（假设地图20×20）：

#### 计算过程
1. **基础距离**：
   - 行距离 = |11-9| = 2，列距离 = |4-4| = 0
   - row_base = 2+1 = 3
   - col_base = 0+1 = 1
   - 因为列距离为0，col_base = row_base = 3

2. **边界检查**：
   - 到上边界：9（无限制）
   - 到下边界：10（无限制）
   - 到左边界：4（无限制）
   - 到右边界：15（无限制）
   - 无需调整

3. **初始矩形区域**：
   - min_row = 9-3 = 6，max_row = 9+3 = 12
   - min_col = 4-3 = 1，max_col = 4+3 = 7

4. **分区限制**：
   - 起点行=9，终点行=11 > 9（终点在下半区）
   - 上半区限制到2格：min_row = 9-2 = 7
   - 下半区保持完整：max_row = 12

5. **最终搜索区域**：
   - 行范围：[7, 12]（共6行）
   - 列范围：[1, 7]（共7列）

#### 可视化
```
列:  0  1  2  3  4  5  6  7  8  9
行
 5   .  .  .  .  .  .  .  .  .  .
 6   .  .  .  .  .  .  .  .  .  .
 7   .  ■  ■  ■  ■  ■  ■  ■  .  .  ← 上半区边界（起点-2）
 8   .  ■  ■  ■  ■  ■  ■  ■  .  .  ← 上半区（限制范围）
 9   .  ■  ■  ■  S  ■  ■  ■  .  .  ← 起点 (9,4)，分界线
10   .  ■  ■  ■  ■  ■  ■  ■  .  .  ← 下半区（完整保留）
11   .  ■  ■  ■  E  ■  ■  ■  .  .  ← 终点 (11,4)
12   .  ■  ■  ■  ■  ■  ■  ■  .  .  ← 下半区边界（起点+3）
13   .  .  .  .  .  .  .  .  .  .

图例：
S = 起点 (9,4)
E = 终点 (11,4)
■ = BFS搜索区域 (6行×7列)
. = 不在搜索区域内
```

#### 设计理念
- **方向性**：终点在下方，所以下半区保留完整（4行），上半区只保留2行
- **对称性**：列方向完全对称（左右各3格）
- **效率性**：避免向终点相反方向过度搜索，减小搜索空间
- **有效性**：保证在绕行范围内能找到路径，又不会搜索过大区域

### 注意事项

- 坐标从 (0,0) 开始，行列范围分别为 [0, rows-1] 和 [0, cols-1]
- 负坐标或越界的箱子会被自动忽略
- 目标数量必须 ≥ 有效箱子数量，否则返回 -8
- 路径缓存不足会返回 -7，建议适当增大 `path_capacity`
- 单个箱子推行超过 5000 步视为无解，返回 -5
- **路径连续性保证**：生成的路径每一步只改变行或列之一，曼哈顿距离为1，无跳跃或对角线移动
- **箱子与目标关系**：
  - 每个箱子可以推向任意目标点（初始时自动贪心分配）
  - 箱子到达目标后消失（内部标记为-1,-1坐标）
  - 每个目标点只会被一个箱子使用，不会重复分配
- **绕行策略（BFS + 双模式）**：
  - **BFS限定区域搜索**：
    * 以起点到终点距离+1为基础确定搜索区域
    * 分区优化：终点方向保持完整，反方向只保留2格
    * 边界自适应：超出地图边界时自动调整
    * 使用BFS保证找到区域内最短路径
  - **车辆模式**（自由移动）：
    * 允许中途恢复贪心，一旦检测到前方通畅立即停止绕行
    * 效率优先，路径可能更短
  - **箱子模式**（精确定位）：
    * 禁止中途打断，必须完整到达目标推箱位才停止
    * 可靠性优先，确保到达精确位置
  - **智能双模式策略**：
    * 绕行换推箱位时先尝试车辆模式（快速）
    * 如果未到达推箱位，从起点重新使用箱子模式（可靠）
    * 兼顾效率和可靠性
- **智能多推箱位尝试**（绕行换推箱位的核心）：
  - 每次推箱时评估所有4个推箱位（上下左右方向），找出所有可行的（不会死锁的）
  - 按评分排序可行推箱位（距离优先，兼顾邻域拥挤度、车距和反向惩罚）
  - 从最优推箱位开始依次尝试：
    * 车已在推箱位 → 直接成功
    * 贪心到达推箱位 → 成功
    * **绕行到达推箱位** → 成功（这就是"绕行换推箱位"）
    * 绕行也失败 → 自动尝试次优推箱位
  - 提高了规划成功率，避免因单一推箱位受阻而放弃

---

## 更新历史

### v3.1 (2025-12-06) - BFS绕行 + 智能双模式策略

#### 核心改进

1. **BFS限定区域绕行算法**（替代原右手/左手法则）：
   - 以起点到终点距离+1为基础确定搜索矩形区域
   - 自动适应地图边界（超出时以实际边界为准）
   - 分区优化：终点方向保持完整，反方向只保留2格行距离
   - 使用BFS保证在限定区域内找到最短路径
   - 自动避开所有障碍物和箱子（箱子当作障碍物处理）

2. **车辆模式 vs 箱子模式**：
   - **车辆模式** (`allow_greedy_resume=1`)：
     * 用于车辆自由移动（不推箱子时）
     * BFS过程中每访问一个点都检测是否可恢复贪心
     * 一旦前方通畅立即停止绕行，切换回贪心
     * 效率优先，路径可能更短
   - **箱子模式** (`allow_greedy_resume=0`)：
     * 用于车辆绕行到精确推箱位
     * BFS禁止中途打断，必须完整到达目标推箱位
     * 可靠性优先，确保位置精确

3. **智能双模式验证策略**：
   - 绕行到推箱位时先尝试车辆模式（提高效率）
   - 验证是否到达推箱位，未到达则从起点重新使用箱子模式（确保可靠）
   - 多重保障：3次尝试机制（车辆模式 → 箱子模式 → 换方向箱子模式）
   - 兼顾效率和可靠性

4. **反向惩罚改进**（5的n次方递进式）：
   - 从固定惩罚50改为5^n（n为连续反向次数）
   - 第1次反向：5，第2次：25，第3次：125，第4次：625...
   - 指数级增长，强力防止震荡
   - 改变方向后自动重置计数器
   - 温和起步但惩罚递增，更加灵活

#### 优势

- ✅ **搜索更精确**：BFS限定区域避免全图搜索，提高效率
- ✅ **路径更优**：BFS保证在限定区域内找到最短路径
- ✅ **自适应边界**：接近地图边缘时自动调整搜索范围
- ✅ **分区优化**：避免向终点相反方向过度搜索
- ✅ **效率优先**：先尝试车辆模式，快速绕行
- ✅ **可靠保底**：车辆模式失败时箱子模式确保到达
- ✅ **防震荡强化**：反向惩罚递增，有效防止反复推箱

#### 技术细节

- BFS队列和访问标记使用静态数组（最大400格）
- parent数组记录路径用于回溯
- 路径验证机制确保每步曼哈顿距离为1
- 箱子处理：skip_idx=box_count确保所有箱子都被视为障碍物

### v3.0 (之前) - 贪心 + 绕行简化版

- 去掉拐点最小化和路径简化
- 使用右手/左手法则绕行（已替换为BFS）
- 固定反向惩罚50（已改为5^n）
