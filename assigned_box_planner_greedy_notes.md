# assigned_box_planner_greedy_1 算法文档

## 算法概述（简化版 v3）
- **核心策略**：贪心规划 + 障碍/箱子绕行，去掉拐点最小化和路径简化
- **选择箱子顺序**：按贪心策略（车到箱子+箱子到目标的曼哈顿距离最小）
- **车到推箱位**：先贪心移动，遇障碍或路径重复时贴障碍绕行，通畅后恢复贪心
- **推箱子**：贪心选择方向，检查死点；遇死点时贴箱子绕行到另一个推箱位
- **容量限制**：最多 10 个箱子，网格最大 400 单元格（20×20），路径缓存根据需要设置
- **目标匹配**：
  - 自动分配箱子到目标（贪心策略，每个箱子可对应任意目标点）
  - 支持目标数≥箱子数（多余目标不使用）
  - 箱子到达目标后，箱子消失（坐标标记为-1），目标点也不再被其他箱子使用

## 函数接口（v3 简化版）
```c
#include "assigned_box_planner_greedy_1.h"

int plan_boxes_greedy_v3(int rows, int cols, PlannerPointV3 car,
                         const PlannerPointV3 *boxes, size_t box_count,
                         const PlannerPointV3 *targets, size_t target_count,
                         const PlannerPointV3 *obstacles, size_t obstacle_count,
                         PlannerPointV3 *path_buffer, size_t path_capacity,
                         size_t *out_steps,
                         size_t *out_box_target_indices /* 可为 NULL */);
```

### 参数说明
- `rows/cols`：网格行数/列数，总单元格数需 ≤400
- `car`：小车初始坐标
- `boxes`/`box_count`：箱子列表及数量（最多 10 个，负坐标或越界的箱子会被忽略）
- `targets`/`target_count`：目标点列表及数量（需 ≥ 有效箱子数，多余目标不使用）
- `obstacles`/`obstacle_count`：障碍物列表及数量
- `path_buffer`/`path_capacity`：输出路径缓存及容量（仅包含小车轨迹，不含箱子位置）
- `out_steps`：输出实际路径步数
- `out_box_target_indices`：可选，输出箱子到目标的映射关系（下标对应 `targets` 数组，未分配为 `SIZE_MAX`）

### 返回值
- `0`：成功
- `-1`：参数为空或无效
- `-2`：箱子或目标为空
- `-3`：箱子数超限（>10）
- `-4`：路径缓存容量为0
- `-5`：单箱迭代超步数（5000步）
- `-6`：无可行推动方向或车无法到达推箱位
- `-7`：路径缓存容量不足
- `-8`：目标数少于箱子数

## 使用示例

### 基础示例（默认地图）
```c
#include "assigned_box_planner_greedy_1.h"

// 使用 rt1064/project/user/src/main.c 中的默认地图
// 14×10 网格
PlannerPointV3 car = {1, 2};
PlannerPointV3 boxes[] = {
    {1, 7},
    {7, 4},
    {10, 4},
};
PlannerPointV3 targets[] = {
    {9, 5},
    {9, 6},
    {9, 7},
};
PlannerPointV3 obstacles[] = {
    {5, 1},  {6, 1},  {7, 1},  {8, 1},
    {0, 7},  {2, 7},  {3, 7},  {4, 7},
    {4, 6},  {4, 5},  {5, 5},  {6, 5},
    {7, 5},  {8, 5},  {8, 6},  {8, 7},
    {8, 8},  {9, 8},  {10, 8}, {11, 8},
    {12, 8}, {12, 7}, {12, 6}, {12, 5},
    {12, 4}, {12, 3}, {11, 3}, {10, 3},
    {10, 5}, {10, 6}, {1, 9},
};

PlannerPointV3 path[2048];
size_t steps = 0;
size_t mapping[3] = {SIZE_MAX, SIZE_MAX, SIZE_MAX};  // 可为 NULL

int ret = plan_boxes_greedy_v3(14, 10, car,
                               boxes, 3,
                               targets, 3,
                               obstacles, sizeof(obstacles) / sizeof(obstacles[0]),
                               path, sizeof(path) / sizeof(path[0]),
                               &steps, mapping);

if (ret == 0) {
    // 成功规划
    printf("路径总步数: %zu\n", steps);
    
    // 打印箱子到目标的映射
    for (size_t i = 0; i < 3; ++i) {
        if (mapping[i] != SIZE_MAX) {
            printf("箱子[%zu] (%d,%d) -> 目标[%zu] (%d,%d)\n",
                   i, boxes[i].row, boxes[i].col,
                   mapping[i], targets[mapping[i]].row, targets[mapping[i]].col);
        }
    }
    
    // 遍历小车路径
    for (size_t i = 0; i < steps; ++i) {
        printf("步骤 %zu: (%d, %d)\n", i, path[i].row, path[i].col);
    }
} else {
    // 错误处理
    printf("规划失败，错误码: %d\n", ret);
    switch (ret) {
        case -1: printf("参数为空或无效\n"); break;
        case -2: printf("箱子或目标为空\n"); break;
        case -3: printf("箱子数超限\n"); break;
        case -4: printf("路径缓存容量为0\n"); break;
        case -5: printf("单箱迭代超步数\n"); break;
        case -6: printf("无可行推动方向\n"); break;
        case -7: printf("路径缓存容量不足\n"); break;
        case -8: printf("目标数少于箱子数\n"); break;
    }
}
```

### 算法特点说明

1. **贪心策略与目标分配**：
   - **初始分配**：使用贪心算法为每个箱子分配一个目标点（车到箱子+箱子到目标距离最小）
   - **箱子顺序**：按车到箱子+箱子到目标的总距离动态排序
   - **推箱方向**：评估所有4个方向，选择评分最优的
   - **多方向尝试**：如果最优方向的推箱位无法到达，自动尝试次优方向
     * 按评分排序所有可行方向（距离+邻域拥挤度+反向惩罚）
     * 从最优到次优依次尝试，直到成功
     * 避免因单一方向被阻挡而整体失败
   - **箱子消失**：箱子到达目标后标记为(-1,-1)，后续路径规划中自动忽略
   - **目标独占**：每个目标点只分配给一个箱子，箱子到达后该目标不再被使用
   - 避免反向推动和邻域拥挤位置

2. **绕行机制**：
   - **车遇障碍**：检测路径重复（20步窗口内重复≥3次），启动贴障碍绕行
   - **车绕行模式**：允许中途检测并恢复贪心（一旦前方通畅立即恢复贪心）
   - **箱子遇死点**：检测推动后是否导致死锁，若死锁则贴箱子绕行换推箱位
   - **箱子绕行模式**：**禁止中途打断**，必须完整到达另一个有效推箱位才停止
     * 先找出箱子周围所有4个推箱位中的有效推箱位（不会导致死锁）
     * 按距离排序有效推箱位（从近到远）
     * 依次尝试每个推箱位，直到成功绕行到达
     * 使用贴障碍绕行到达推箱位，中途不检测贪心恢复
     * 如果最近的推箱位被阻挡，自动尝试其他有效推箱位

3. **死点检测与目标到达**：
   - 每次推箱前检查新位置能否继续到达目标
   - 使用BFS验证箱子从新位置的可达性
   - **特殊处理**：当推箱后箱子直接到达目标点时
     * 不进行死点检测（因为已经是终点）
     * 只检查推箱位是否可达（不是障碍或其他箱子）
     * 允许推进目标点（即使目标点本身有特殊情况）

4. **路径输出**：
   - `path_buffer` 仅包含**小车轨迹**（不含箱子位置）
   - **保证连续性**：每一步都是相邻单元格（曼哈顿距离为1），只改变行或列之一
   - 内置多重路径验证机制：
     * 绕行路径复制时验证连续性
     * 贪心移动时验证每个新点与前一点相邻
     * 推箱后车位置验证连续性
     * 最终路径整体验证
   - 任何不连续都会被检测并返回错误码 -6
   - 建议缓存容量至少为 `rows × cols × box_count × 10`

### 注意事项

- 坐标从 (0,0) 开始，行列范围分别为 [0, rows-1] 和 [0, cols-1]
- 负坐标或越界的箱子会被自动忽略
- 目标数量必须 ≥ 有效箱子数量，否则返回 -8
- 路径缓存不足会返回 -7，建议适当增大 `path_capacity`
- 单个箱子推行超过 5000 步视为无解，返回 -5
- **路径连续性保证**：生成的路径每一步只改变行或列之一，曼哈顿距离为1，无跳跃或对角线移动
- **箱子与目标关系**：
  - 每个箱子可以推向任意目标点（初始时自动贪心分配）
  - 箱子到达目标后消失（内部标记为-1,-1坐标）
  - 每个目标点只会被一个箱子使用，不会重复分配
- **绕行策略差异**：
  - **车辆绕行**：允许中途恢复贪心，一旦检测到前方通畅立即停止绕行
  - **箱子绕行**：禁止中途打断，必须完整到达有效的推箱位才停止（确保换推箱位的完整性）
- **智能多方向尝试**：
  - 每次推箱时评估所有4个方向，找出所有可行的（不会死锁的）
  - 按评分排序可行方向（距离优先，兼顾邻域拥挤度和反向惩罚）
  - 从最优方向开始依次尝试，如果车无法到达该方向的推箱位，自动尝试次优方向
  - 只有所有可行方向的推箱位都无法到达时才换推箱位（绕箱子）
  - 提高了规划成功率，避免因单一方向受阻而放弃
